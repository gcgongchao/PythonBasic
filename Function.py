#函数
#Python内置了很多有用的函数，我们可以直接调用。调用Python的函数，需要根据函数定义，传入正确的参数。
#如果函数调用出错，一定要学会看错误信息，所以英文很重要。
#函数名其实就是指向一个函数对象的引用，完全可以把函数名赋給一个变量，相当于给这个函数起了
#一个“别名”.
#在python中，定义一个函数要使用def语句,依次写出函数名，括号，括号中的参数和冒号：，然后，在缩进块
#中编写函数体，函数的返回值用return语句返回.请注意，函数体内部的语句在执行时，一旦执行到return时，函数就
#执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数
#执行完毕后也会返回结果，只是结果为None
#return None可以简写为return
#空函数：如果想定义一个什么事也不做的空函数，可以用pass语句。pass可以用来作为占位符，就是函数体还没有想好怎么写，用来占位。
#参数检查：调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError，但如果参数类型不对，Python解释器
#就无法帮我们检查。
#数据类型检查可以用内置函数isinstance()实现
#返回多个值：Python中函数返回的是一个tuple.但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，
#按位置赋給对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便.

#定义函数时，需要确定函数名和参数个数；如果有必要，可以先对参数的数据类型做检查；函数体内部可以用return随时返回函数结果；函数执行完毕也没有return语句时，自动return none;函数可以同时返回多个值，但其实就是一个tuple。
#Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数，可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。
#默认参数可以简化函数的调用。设置默认参数时，有几点要注意：（1）必选参数在前，默认参数在后，否则Python的解释器会报错（2）如何设置默认参数，当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。使用默认参数最大的好处是能降低调用函数的难度。
#当有多个默认参数时，调用的时候，既可以按顺序提供部分默认参数，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。默认参数很有用，但使用不当，也会掉坑里。定义默认参数要牢记一点：默认参数必须指向不变对象。
#为什么要设计str,None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
#可变参数：在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个，2个到任意个，还可以是0个。定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。如果已经有一个list或tuple要当参数传递进去怎么办？Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。
#关键字参数：可变参数允许你传入0个或者任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
#注意：可变参数声明时是一个*，关键字参数声明时是两个*
#命名关键字参数：对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在内部获取检查。如果要限制关键字参数的名字，就可以用命名关键字参数，和关键字参数不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数。命名关键字参数也可以有缺省值
#参数组合：在Python中定义函数，可以用必选参数，默认参数，可变参数，关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数，默认参数，可变参数，命名关键字参数和关键字参数。对于任意函数，都可以通过类似func(*args,**kw)的形式调用它，无论它的参数是如何定义的。
#Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误。要注意定义可变参数和关键字参数的语法:*是可变参数，接收的是一个tuple；**是关键字参数，接收的是一个dict。命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数在没有可变参数的情况下不要忘了写分隔符*,否则定义的将是位置参数。


#在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

#解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以把循环看成是一种特殊的尾递归函数也是可以的。尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。

#使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

import math

a=abs
print(a(-1))
print(str(hex(10)))

def my_abs(x):
	if not isinstance(x,(int,float)):
		raise TypeError('bad operand type')
	if(x>=0):
		return x
	else:
		return -x

print(my_abs(-10))


def nop():
	pass
#print(my_abs('A'))
def move(x,y,step,angle=0):
	nx=x+step*math.cos(angle)
	ny=y-step*math.sin(angle)
	return nx,ny
x,y=move(2,2,3,60)
print(x,y)
print('###############################')

def power(x,n=2):
	s=1
	while n>0:
		n=n-1
		s=s*x
	return s
print(power(5,3))

def add_end(L=None):
	if L is None:
		L=[]
	L.append('END')
	return L
print(add_end([1,2,3]))
print(add_end(['X','Y',"Z"]))
print(add_end())
print(add_end())
print(add_end())

def calc(*numbers):#可变参数
	sum=0
	for n in numbers:
		sum=sum+n*n
	return sum
print(calc(1,2))
print(calc())
num=[1,2,3]
print(calc(*num))

print('**************************')
def person(name,age,**kw):
	if 'city' in kw:
		pass
	print('name:',name,'age:',age,'other:',kw)

print(person('hello',12))
print(person('hello',12,city='Beijing'))
print(person('hello',12,geneder='M',job='engineer'))
extra={'city':'Beijing','job':'engineer'}
print(person('hello',12,**extra))


def person(name,age,*,city,job):
	print(name,age,city,job)
person('Jack',24,city='Beijing',job='Engineer')

print('****************')
def f1(a,b,c=0,*args,**kw):
	print('a=',a,'b=',b,'c=',c,'args=',args,'kw=',kw)

def f2(a,b,c=0,*,d,**kw):
	print('a=',a,'b=',b,'c=',c,'d=',d,'kw=',kw)
f1(1,2)
f1(1,2,c=3)
f1(1,2,3,'a','b')
f1(1,2,3,'a','b',x=99)
f1(1,2,d=99,ext=None)
f2(1,2,d=99,ext=None)

args=(1,2,3,4)
kw={'d':99,'x':'#'}
f1(*args,**kw)
args=(1,2,3)
kw={'d':88,'x':'#'}
f2(*args,**kw)


print('&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&')

def fact(n):
	if n==1:
		return 1
	return n*fact(n-1)


def fact1(n):
	return fact_iter(n,1)
def fact_iter(num,product):
	if num==1:
		return product
	return fact_iter(num-1,num*product)




