#!/usr/bin/env python3
#-*-coding:utf-8-*-

'a test module'

__author__='GeneralAndroid'

#模块：在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
# 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，
# 很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。
# 使用模块有什么好处？最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。
# 当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，
# 包括Python内置的模块和来自第三方的模块。使用模块还可以避免函数名和变量名冲突。
# 相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，
# 不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。为了避免模块名冲突，
# Python又引入了按目录来组织模块的方法，称为包(Package)。注意：每一个包目录下面都会有一个_init_.py的文件，
# 这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。_init_.py可以是空文件，
# 也可以有Python代码。另外_init_.py本身就是一个模块。自己创建模块时要注意命名，不能和Python自带的模块名称冲突。

#使用模块：Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。
# Python模块的标准文件模板：第一行和第二行是标准注释，第四行是一个字符串，表示模块的文档注释，
# 任何模块代码的每一个字符串都被视为模块的文档注释；第6行__author__变量是作者名。当然这些也可以全部删掉不写，但是，按标准办事肯定没错。

import sys

def test():
	args=sys.argv
	if len(args)==1:
		print('Hello,world!')
	elif len(args)==2:
		print('Hello,%s'%args[1])
	else:
		print('Too many arguments')
if __name__=='__main__':#当我们在命令行运行该模块文件时，Python解释器把一个特殊变量__name__置为__main__,而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码。最常见的就是运行测试。
	test()

#作用域：在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，
# 有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
# 正常的函数和变量名是公开的(public)，可以被直接引用。类似__XXX__这样的变量是特殊变量，可以被直接引用，
# 但是有特殊用途，我们自己的变量一般不要用这种变量名。类似_xxx和__xxx这样的函数或变量就是非公开的(private)，
# 不应该被直接引用。之所以我们说，private函数和变量"不应该"被直接引用，而不是“不能”被直接引用，
# 是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

#from PIL import Image
#from PIL import ImageDraw
#im=Image.open('test.png')
#print(im.format,im.size,im.mode)
#im.thumbnail(200,100)
#im.save('thumb.jpg','JPEG')


#模块搜索路径：当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错，
# ImportError。默认情况下，Python解释器会搜索当前目录，所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。
# 如果我们要添加自己的搜搜目录，有两种方法：（1）一是直接修改sys.path，添加要搜索的目录。这种方法是在运行时修改，运行结束后失效。
# 第二方法是设置环境变量PYTHONPATH，该环境变量的内容被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。
# 注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。

